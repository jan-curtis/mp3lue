import os
import sys
import logging
import argparse
from pathlib import Path
import yaml
from pydub import AudioSegment
from mutagen.mp3 import MP3
from mutagen.id3 import ID3, TIT2, COMM, TCON, TALB, TPE1
from tqdm import tqdm

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

class MP3Concatenator:
    def __init__(self, config):
        """Initialize the MP3 concatenator with configuration."""
        self.config = config
        self.input_dir = Path(config['input_dir'])
        self.output_dir = Path(config['output_dir'])
        self.output_file = self.output_dir / config['output_filename']
        
        # Create output directory if it doesn't exist
        self.output_dir.mkdir(parents=True, exist_ok=True)

    def get_sorted_chapters(self):
        """Get and sort MP3 files from the input directory."""
        try:
            files = [f for f in self.input_dir.glob('*.mp3') if f.is_file()]
            if not files:
                raise FileNotFoundError(f"No MP3 files found in {self.input_dir}")
            return sorted(files)
        except Exception as e:
            logger.error(f"Error getting MP3 files: {e}")
            raise

    def concatenate_chapters(self, sorted_files):
        """Concatenate audio files and collect chapter names."""
        try:
            combined_audio = AudioSegment.empty()
            chapter_names = []
            
            for file in tqdm(sorted_files, desc="Processing files"):
                logger.info(f"Processing {file.name}")
                audio = AudioSegment.from_mp3(file)
                combined_audio += audio
                chapter_name = file.stem  # Get filename without extension
                chapter_names.append(chapter_name)
            
            return combined_audio, chapter_names
        except Exception as e:
            logger.error(f"Error concatenating files: {e}")
            raise

    def add_metadata(self, output_path, chapter_names):
        """Add metadata to the final MP3 file."""
        try:
            audio = MP3(output_path, ID3=ID3)

            try:
                audio.add_tags()
            except Exception:
                pass  # Tags might already exist

            # Add basic metadata
            audio.tags.add(TIT2(encoding=3, text=self.config['title']))
            audio.tags.add(TPE1(encoding=3, text=self.config['author']))
            audio.tags.add(TCON(encoding=3, text=self.config.get('genre', 'Audiobook')))
            audio.tags.add(COMM(encoding=3, desc="Comment", text=self.config.get('comment', '')))

            # Add chapter information
            for idx, chapter in enumerate(chapter_names, 1):
                audio.tags.add(COMM(encoding=3, desc=f"Chapter {idx}", text=chapter))

            audio.save()
            logger.info(f"Metadata added to {output_path}")
        except Exception as e:
            logger.error(f"Error adding metadata: {e}")
            raise

    def process(self):
        """Main processing function."""
        try:
            # Get and sort files
            sorted_files = self.get_sorted_chapters()
            
            # Concatenate files
            combined_audio, chapter_names = self.concatenate_chapters(sorted_files)
            
            # Export concatenated audio
            combined_audio.export(self.output_file, format="mp3")
            logger.info(f"Audio concatenated and saved to {self.output_file}")
            
            # Add metadata
            self.add_metadata(self.output_file, chapter_names)
            
            return True
        except Exception as e:
            logger.error(f"Processing failed: {e}")
            return False

def load_config(args):
    """Load configuration from file and command line arguments."""
    config = {
        'title': 'Combined Audiobook',
        'author': 'Unknown',
        'input_dir': './',
        'output_dir': './',
        'output_filename': 'combined.mp3',
        'genre': 'Audiobook',
        'comment': 'Generated by MP3 Concatenator'
    }
    
    # Load from config file if exists
    config_file = Path('config.yaml')
    if config_file.exists():
        with open(config_file) as f:
            file_config = yaml.safe_load(f)
            config.update(file_config)
    
    # Override with command line arguments
    if args.title:
        config['title'] = args.title
    if args.author:
        config['author'] = args.author
    if args.input_dir:
        config['input_dir'] = args.input_dir
    if args.output_dir:
        config['output_dir'] = args.output_dir
    if args.output_filename:
        config['output_filename'] = args.output_filename
    
    return config

def main():
    parser = argparse.ArgumentParser(description='MP3 Concatenator - Combine MP3 files with metadata')
    parser.add_argument('--title', help='Title of the output mp3 file')
    parser.add_argument('--author', help='Author of the output mp3 file')
    parser.add_argument('--input-dir', help='Input directory containing MP3 files')
    parser.add_argument('--output-dir', help='Output directory for the output mp3 file')
    parser.add_argument('--output-filename', help='Output filename')
    
    args = parser.parse_args()
    
    try:
        config = load_config(args)
        concatenator = MP3Concatenator(config)
        success = concatenator.process()
        
        if not success:
            sys.exit(1)
            
    except Exception as e:
        logger.error(f"Fatal error: {e}")
        sys.exit(1)

if __name__ == "__main__":
    main()